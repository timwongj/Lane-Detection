# SIMPLE LANE DETECTION

    # convert to hsv (image, cv2.COLOR_BGR2HSV)
    hsv = cv2.cvtColor(img2, cv2.COLOR_BGR2HSV)

    # apply gaussian blur (image, (kernel_size, kernel_size), 0)
    kernel_size = 3
    g_blur = cv2.GaussianBlur(hsv, (kernel_size, kernel_size), 0)

    # filter yellow and white
    yellow_min = np.array([65, 80, 80], np.uint8)
    yellow_max = np.array([105, 255, 255], np.uint8)
    yellow_mask = cv2.inRange(img, yellow_min, yellow_max)

    white_min = np.array([0, 0, 200], np.uint8)
    white_max = np.array([255, 80, 255], np.uint8)
    white_mask = cv2.inRange(img, white_min, white_max)

    c_filter = cv2.bitwise_and(img, img, mask=cv2.bitwise_or(yellow_mask, white_mask))

    # use canny edge detector to detect edges
    low_threshold = 30
    high_threshold = 130
    canny = cv2.Canny(c_filter, low_threshold, high_threshold)
    CANNY_IMG = image

    # calculate region of interest
    # defining a blank mask to start with
    mask = np.zeros_like(canny)
    ysize = base.shape[0]
    xsize = base.shape[1]
    vertices = np.array([[(40, ysize), (xsize / 2, ysize / 2 + 40), (xsize / 2, ysize / 2 + 40), (xsize - 40, ysize)]], dtype=np.int32))

    # defining a 3 channel or 1 channel color to fill the mask with depending on the input image
    if len(canny.shape) > 2:
        channel_count = canny.shape[2]  # i.e. 3 or 4 depending on your image
        ignore_mask_color = (255,) * channel_count
    else:
        ignore_mask_color = 255

    # filling pixels inside the polygon defined by "vertices" with the fill color
    cv2.fillPoly(mask, vertices, ignore_mask_color)

    # returning the image only where mask pixels are nonzero
    masked_image = cv2.bitwise_and(canny, mask)
    
    # calculate hough lines
    lines = cv2.HoughLinesP(masked_image, i, np.pi / 90, 10, np.array([]), minLineLength=min_line_len, maxLineGap=max_line_gap)
    height, width = img.shape
    line_img = np.zeros((height, width, 3), dtype=np.uint8)

    draw_lines(line_img, lines, thickness=7)

    image = hough_lines(image, 1, np.pi / 90, 10, 15, 10)
